Solidity智能合约性能文档更新地址：https://shimo.im/docs/3sAFRzavWFkJ7zbp上线软件 = 代码 + 数据 + 文档；Dapp开发中需互信逻辑：智能合约 = 代码 + 数据 +（文档：白皮书？）；Solidity智能合约开发入门：https://solidity-cn.readthedocs.io/zh/develop/Solidity智能合约最佳实践：https://consensys.github.io/smart-contract-best-practicesRemix在线编辑器：http://remix.ethereum.org/Remix使用文档：https://remix.readthedocs.io/en/latest/index.htmlRemix可以使用翻墙的方式进行访问，Solidity智能合约开发比较简单，但是由于智能合约的特殊性，一经部署很难做出修改（以太坊合约、联盟链合约），因此我们将主要的精力放置在智能合约的两个部分：合约安全与合约性能；合约安全：合约上线后能够按照预期正确运行，不会因为漏洞导致合约中出现金额损失及其它一些业务的异常。这要求书写Solidity时应当检查自身的合约是否存在bug。（目前鱼塘在做的一件事情就是合约的安全性检查）安全事故：1、黑客攻击（TheDAO、美链）；2、parity钱包多重签名漏洞（资金被永久冻结）……合约性能：提升性能分为两个部分，第一部分是从自身代码的业务角度，利用更加高效的数据结构及算法对自身合约性能进行提升；第二部分是熟悉Solidity底层语法设计逻辑，清楚不同的操作对Gas消耗定性的多与少，从而能够让开发者使用最少的Gas消耗达到同样的代码效果。评价一个合约的性能现实标准是执行合约操作时需要消耗的Gas数量，高效的合约代码能够减少Gas消耗，简洁的逻辑也能避免代码漏洞，最终达到代码花费Gas最少、合约代码安全运行的目的。gasLimit:交易执行时使用gas的上限。一个交易的交易费由两个因素组成：gasUsed：该交易消耗的总gas数量（单位gas可以执行一个单位运算）gasPrice：该交易中单位gas的价格（用以太币计算）交易费 = gasUsed * gasPrice；如何对Solidity智能合约Gas消耗进行估算？以太坊如何估算或者计算gas？remix网页下有一个可执行的log页面，可以查看合约执行详情。有gas cost的地方有两个，transaction cost以及 execution cost。transaction cost指的是将交易送至ethereum blockchain所耗费的cost，是基于data size的大小，部署合约时就是基于合约内容的大小。execution cost指的是虚拟机(VM)执行所需的cost，部署合约时会去执行一些初始化工作。不同的操作对gas消耗的多少？以下为语言层面性能提升点：类型变量的定义EVM每次操作32字节，因此如果数据占用少于32字节，EVM需要更多操作来截取比32字节更少的数据。当合约中的状态变量存在多个不足32字节时，EVM会将这些数据存储在一个槽位，这样对这些变量的读或写是组合进行一次操作的。除非确实有变量会组合性的多次读写，或者对存储空间有特殊限制，否则没有必要将变量定义为少于32字节对类型来迫使他们放在同一个槽位。当确实需要定义不足32字节类型对变量时，为了方便EVM进行优化，有意识的排序这些状态变量，让他们排列的更为紧凑。如下所示：```js// 最推荐的定义方式：各自占满3格槽位struct PerfectStudent {	uint age;	uint height;	uint weight;}// 好的定义方式： 占2个槽位struct GoodStudent {	uint128 age;	uint128 height;	uint256 weight;}// 差的定义方式：占3个槽位struct BadStudent {	uint128 age;	uint256 height;	uint128 weigth;}推荐定义方式，各自占满，一共3个槽位：32字节 uint age;32字节 uint height;32字节 uint weight;好的定义方式，占用2个槽位：18字节 uint128 age;18字节 uint128 height;uint256 weight;差的定义方式，占用3个槽位：18字节 uint128 age;32字节 uint256 height;18字节 uint128 weight;```当合约中的局部变量存在多个不足32字节时，编译器不会进行上述优化，因此对于局部变量推荐定义成全字节类型变量。状态变量和局部变量的读写一段代码清楚的认识状态变量、局部变量。```jspragma solidity ^0.4.4;contract Person {    int public _age;	string public _name;	function Person(int age, string name) {        _age = age;        _name = name;	}	function f(string name) {        var name1 = name;        ......	}}
```在这段代码中，_age，_name就属于状态变量，Person(int age,string name)中的age和name，还有f(string name)中的name以及f( )函数中声明的name1都默认属于本地／局部变量。```jspragma solidity ^0.4.4;contract Person {	int public _age;	function Person(int age) {        _age = age;	}	function f( ) {        midifyAge(_age);	}	function midifyAge(int age) {        age = 100;	}}```memory值传递
```jspragma solidity ^0.4.4;contract Person {    string public _name;    function Person( ) {        _name = "hyperchain";    }    function f( ) {        modifyName(_name);    }        function modifyName(string name)  {        var name1 = name;        bytes(name1)[0] = 'L';    }}
```
上边代码中：
```jsfunction modifyName(string name) {    var name1 = name;    bytes(name1)[0] ='L';}
```
等价于：```jsfunction modifyName(string memory name) {    var name1 = name;    bytes(name1)[0] = 'L';}
```
等价于：

```jsfunction modifyName(string memory name) {    var memory name1 = name;    bytes(name1)[0] = 'L';}
```
等价于：```jsfunction modifyName(string name) {    var memory name1 = name;    bytes(name1)[0] = 'L';}
```
由上面几种写法，我们不难看出，当引用类型作为函数参数时，它的类型默认为memory，函数参数为memory类型的变量给一个变量赋值时，这个变量的类型必须和函数类型一致，所以我们可以写成string memory name1 = name;或者var name1 = name;,var声明一个变量时，这个变量的类型最终由赋值给它值的类型决定。任何函数参数当它的类型为引用类型时，这个函数参数都默认为memory类型，memory类型的变量会临时拷贝一份值存储到内存中，当我们将这个参数值赋给一个新的变量，并尝试去修改这个新的变量的值时，最原始的变量的值并不会发生变化。在本案例中，当创建合约时，name的值为hyperchain，当我们调用f( )函数时，f( )函数中会将name的值赋给临时的memory变量name，换句话说，因为name的类型为memory，所以两个name是分别指向不同的对象的，当我们尝试去修改name指针指向的值时，name所指向的内容不会发生变化。storage指针传递当函数参数为memory类型时，相当于值传递，而storage类型的函数参数将是指针传递。如果想要在modifyName函数中通过传递过来的指针修改name的值，那么必须将函数参数的类型显示设置为storage类型，storage类型拷贝的不是值，而是name指针，当调用modifyName(name)函数时，相当于同时由name，_name和name1三个指针同时指向同一个对象，我们可以通过三个指针中的任何一个指针修改他们共同指向的内容的值。```jspragma solidity ^0.4.4;contract Person {    string public _name;    function Person() {        _name = "hyperchain";    }    function f( ) {        modifyName(_name);    }        function modifyName(string storage name) internal{        string storage name1 = name;        bytes(name1)[0] = 'L';    }}
```代码

```
function modifyName(string storage name) internal {	var name1 = name;	bytes(name1)[0] = ‘L’;}
```等价于```jsfunction modifyName(string storage name) internal {	string storage name1 = name;	bytes(name1)[0] = ‘L’;}
```
在熟悉了状态变量、局部变量、memory、storage之后，我们想要考虑如何利用memory和storage修饰变量优化合约性能。智能合约执行效率很大程度取决于从存储读出到内存，从内存写入到存储的数据量和频率。因此在一个函数中，读写数据量一定的情况下，争取做到一次读或一次写是保证合约执行效率的极大优化点。一般的原则是，对于函数的入参（局部变量）和函数内部新定义的局部变量在尚未持久化之前，统一用memory类型的变量进行处理，直到赋值给状态变量，即完成从内存到存储的写入；对于合约状态变量的读取，如果是频繁使用的变量，建议在函数内部定义局部变量并赋值，否则直到最后函数返回时作最后的赋值。循环防止循环次数太多尽可能保证一个循环的次数不超过1000，且每次循环中，执行的代码尽可能简单。避免重复访问磁盘如果在每个循环中，存在某个变量被重复使用，建立将该变量的值取出在内存中，而非重复访问磁盘来读取。```jsuint[ ] array;function badLoop( ) {	for(uint i = 0; i < array.length; ++i){        array[i] += 1;	}}function goodLoop( ) {	uint length = array.length;	for(uint i = 0; i < length; ++i) {       array[i] += 1;	}}
```
使用左值运算使用左值运算对于循环中出现的右值运算++，若可以使用左值运算++，则尽量使用左值运算，减少不必要的指令执行。a++和a--相当于a += 1 / a -= 1,- -a和a++与a有与上一条相同的效果，但是等值发生改变后才返回运算结果。快速删除数组删除全部在数组上使用delete删除其所有元素或者将数组长度置为0.封装集合参考GitHub源码，其中有对map及set的封装；iterable_mapping.sol:https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol清理空间由于本身并未提供对映射这样的大对象的清理，所以存储并遍历他们来进行删除，显得特别消耗性能。除了封装成维护元素下标的集合等结构外，另一种实践就是能复用就复用，一般不主动清理。下面是一个数组的插入实现，比如增加一个计数器，直接忽略已使用过的位置。```jsuint numElements = 0;uint[ ] array;function insert(uint value) {if(numElements == array.length) {    array.length += 1;}array[numElements++] = value;}function clear( ) {    numElements = 0;}
```
上面的例子中，我们在数组新增时，直接忽略掉已使用过的槽位。而在代码内，我们使用numElements来代替array.length,以获取当前数组所在的位置。如果这种大对象是在某个事件发生时，一次性使用，然后需要回收的，一个更有效的方式是，在发生某个事件时，创建一个新合约，在新合约完成逻辑，完成后，让合约suicide。通过清理整个合约来释放合约内全部的变量空间。字符串比较遍历比较对应bytes类型的字符串，首先比较长度，若长度一致，再逐个字节比较，直到全部字节相同才判断为相同，否则为不同。```jsfunction equal ( bytes a,bytes b ) returns (bool) {	if(a.length != b.length) {   		return false;	}	uint length == a.length;	for(uint i = 0;i < length; ++i) {   		if(a[i] != b[i]){   			return false;		}	}	return true;}
```
转为哈希比较直接将字符串转为哈希，通过比较哈希判断两个字符串是否相同。虽然存在一定几率的哈希碰撞，但效率更快。

```jsfunction equal(bytes a, bytes b) returns (bool) {   	return sha256(a) == sha256(b);}
```string与bytesstring尽量不要用，推荐使用固定长度对bytes数组代替。业务层面优化代码处理原则为：不要将所有的业务处理都放在合约中进行，仅仅将关键部分代码放置在合约中；尽量将代码逻辑简化，耦合度较高的逻辑可以尝试解耦，不同的部分放置在不同的合约进行处理。尝试寻找一些已经上线且被验证过对合约代码阅读，采用模仿的方式进行学习。场景:某机构需要对进行存证溯源操作，要求存证内容可修改同时能够对修改前后所有的内容进行记录；要求在其中加入合理的权限控制模块；